        -:    0:Source:model.c
        -:    0:Graph:model.gcno
        -:    0:Data:model.gcda
        -:    0:Runs:14
        -:    0:Programs:1
        -:    1:#include "smartCalc.h"
        -:    2:
        -:    3:charactersSet set;
        8:    4:charactersSet validator(char * searhString, int point) {
        8:    5:    set.errors = IS_NORMAL;
        8:    6:    set.openBracket = 0;
        8:    7:    set.x = 0;
        8:    8:    set.closedBracket = 0;
        8:    9:    bool fraction = 0;
        8:   10:    int error = 0;
        8:   11:    bool onlyValues = false;
        -:   12:    
        8:   13:    if(point == 0) {
    #####:   14:        set.errors = IS_EMPTY_FEEL;
    #####:   15:    }
        8:   16:    if (searhString[0] == 'x' || searhString[0] == 'm' || searhString[0] == '+') {
        2:   17:        set.errors = IS_SYNTAX_ERROR;
        2:   18:    }
        8:   19:    if (searhString[point - 1] == 'x') {
        1:   20:        set.x = 1;
        1:   21:    }
       15:   22:    if (searhString[point - 1] == '+' || searhString[point - 1] == '-' || searhString[point - 1] == '*'
        7:   23:        || searhString[point] == '/' || searhString[point - 1] == '^' || searhString[point - 1] == '(')  {
        1:   24:        set.errors = IS_SYNTAX_ERROR;
        1:   25:    }
       17:   26:    for (int i = 0;i < point;i++) {
       16:   27:        onlyValues = isValue(searhString[i]);
       16:   28:        fraction = isFractionValue(searhString[i]);
       16:   29:        if (searhString[i] == ',') {
    #####:   30:        }
       16:   31:        if (!onlyValues) {
        7:   32:            break;
        -:   33:        }
        9:   34:    }
        8:   35:    if (onlyValues) {
        1:   36:        set.errors = IS_SYNTAX_ERROR;
        1:   37:    }
        -:   38:    
        8:   39:    if (fraction) {
        2:   40:        set.errors = IS_SYNTAX_ERROR;
        2:   41:    }
        8:   42:    if (point >= 1) {
        8:   43:        if ((searhString[0] == '/' || searhString[0] == '*' || searhString[0] == '^' || searhString[0] == ')')) {
        1:   44:            set.errors = IS_SYNTAX_ERROR;
        1:   45:        }
        8:   46:        int pointer = 1;
       77:   47:        for (int i = point; i > 0; i--) {
       70:   48:            if ((searhString[point - i] == '+' ||  searhString[point - i] == '-' || searhString[point - i] == '*' || searhString[point - i] == '/' || searhString[point - i] == '^' || searhString[point - i] == ',') && ((searhString[pointer] == '+' ||  searhString[pointer] == '-' || searhString[pointer] == '*' || searhString[pointer] == '/' || searhString[pointer] == '^' || searhString[pointer] == ','))) {
        1:   49:                set.errors = IS_SYNTAX_ERROR;
        1:   50:                break;
        -:   51:            }
       69:   52:            pointer++;
       69:   53:        }
        8:   54:        pointer = 1;
       67:   55:        for (int i = point; i > 0; i--) {
       60:   56:            if ((searhString[point - i] == ',') && (searhString[pointer] == '(' || searhString[pointer] == ')')) {
        1:   57:                set.errors = IS_SYNTAX_ERROR;
        1:   58:                break;
        -:   59:            }
       59:   60:            pointer++;
       59:   61:        }
        8:   62:        if (searhString[point - 1] == ',') {
    #####:   63:            set.errors = IS_SYNTAX_ERROR;
    #####:   64:        }
       85:   65:        for (int i = 0; i < point; i++) {
       77:   66:            if (searhString[i] == '(') {
        6:   67:                set.openBracket += 1;
        6:   68:            }
       77:   69:            if (searhString[i] == ')') {
        5:   70:                set.closedBracket += 1;
        5:   71:            }
       77:   72:        }
        8:   73:        if (set.openBracket != set.closedBracket) {
        1:   74:            set.errors = IS_SYNTAX_ERROR;
        1:   75:        }
        8:   76:        pointer = 1;
       85:   77:        for (int i = point; i > 0; i--) {
       77:   78:            if (searhString[point - i] == '(' && searhString[pointer] == ')') {
        1:   79:                set.errors = IS_SYNTAX_ERROR;
        1:   80:            }
       77:   81:            pointer++;
       77:   82:        }
        8:   83:        pointer = 1;
       66:   84:        for (int i = point; i > 0; i--) {
       59:   85:            if ( searhString[point - i] == '(' && ((searhString[pointer] == '+'  || searhString[pointer] == '*' || searhString[pointer] == '/' || searhString[pointer] == '^' || searhString[pointer] == ','))) {
        1:   86:                set.errors = IS_SYNTAX_ERROR;
        1:   87:                break;
        -:   88:            }
       58:   89:            pointer++;
       58:   90:        }
        8:   91:        pointer = 1;
       67:   92:        for (int i = point; i > 0; i--) {
       60:   93:            if (searhString[point - i] == ',') {
        1:   94:                if (point - i == 0) {
    #####:   95:                    set.errors = IS_SYNTAX_ERROR;
    #####:   96:                    break;
        -:   97:                }
        1:   98:                if (isValue(searhString[((point - i) - 1)]) && isValue(searhString[pointer])) {
    #####:   99:                } else {
        1:  100:                    set.errors = IS_SYNTAX_ERROR;
        1:  101:                    break;
        -:  102:                }
    #####:  103:            }
       59:  104:            pointer++;
       59:  105:        }
        8:  106:    } else {
    #####:  107:        set.errors = IS_SYNTAX_ERROR;
        -:  108:    }
        8:  109:    return set;
        -:  110:}
        -:  111:
       17:  112:bool isValue(char  ch) {
       17:  113:    bool isValue = false;
       17:  114:    if (ch >= 48 && ch <= 57 ) {
        9:  115:        isValue = true;
        9:  116:    }
       17:  117:    return isValue;
        -:  118:}
        -:  119:
       16:  120:bool isFractionValue(char ch) {
       16:  121:    bool isValue = false;
       16:  122:    if ((ch >= 48 && ch <= 57) || ch == 46) {
       10:  123:        isValue = true;
       10:  124:    }
       16:  125:    return isValue;
        -:  126:}
        -:  127:
        5:  128:double calculator (char * searchString, int point, charactersSet * set, double x_coordinate) {
        -:  129:    Stack_t stack_n;
        5:  130:    stack_n.size = 0;
        -:  131:    Stack_t stack_o;
        5:  132:    stack_o.size = 0;
        -:  133:    value_type item;
        -:  134:    char ch;
        -:  135:    bool res;
        -:  136:    char  value[500];
        5:  137:    int pointer = 0;
        -:  138:    double value_d;
        5:  139:    int matchValue = 0;
        5:  140:    int flag = 1;
        -:  141:    
       45:  142:    for (int i = 0; i < point; i++) {
       40:  143:        if (searchString[i] == 'x') {
    #####:  144:            item.type = '0';
    #####:  145:            item.value = x_coordinate;
    #####:  146:            push(&stack_n, item);
    #####:  147:        }
       70:  148:        while ((searchString[i] >= '0' && searchString[i] <= '9' || searchString[i] == '-' && flag == 1) || searchString[i] == ',') {
       30:  149:            ch = searchString[i];
       30:  150:                                   if (ch == ',') {
        2:  151:                                       ch = '.';
        2:  152:                                   }
       30:  153:            value[pointer] = ch;
       30:  154:            flag = 0;
       30:  155:            matchValue = 1;
       30:  156:            pointer++;
       30:  157:            i++;
        -:  158:        }
       40:  159:        if (matchValue) {
       17:  160:            value[pointer] = '\0';
       17:  161:            sscanf(value,"%lf",&value_d);
       17:  162:            item.type = '0';
       17:  163:            item.value = value_d;
       17:  164:            push(&stack_n, item);
       17:  165:            pointer = 0;
       17:  166:        }
       40:  167:        if (searchString[i] == 's' || searchString[i] == 'c' || searchString[i] == 'a' || searchString[i] == 'l' || searchString[i] == 't') {
        -:  168:            char func[4];
        8:  169:            size_t lenght = 0;
       36:  170:            for (int j = 0; j < 4;j++) {
       32:  171:                if (searchString[i] >= 97 && searchString[i] <= 122) {
       28:  172:                    func[j] = searchString[i];
       28:  173:                    lenght+=1;
       28:  174:                    i++;
       28:  175:                } else {
        4:  176:                    break;
        -:  177:                }
       28:  178:            }
        8:  179:            if(lenght == 3) {
        -:  180:                // sin
        4:  181:                if (func[0] == 's' && func[1] == 'i' && func[2] == 'n') {
        1:  182:                    item.type = 's';
        1:  183:                    item.value = 0;
        1:  184:                    push(&stack_o, item);
        1:  185:                }
        -:  186:                // cos
        4:  187:                if (func[0] == 'c' && func[1] == 'o' && func[2] == 's') {
        2:  188:                    item.type = 'c';
        2:  189:                    item.value = 0;
        2:  190:                    push(&stack_o, item);
        2:  191:                }
        -:  192:                // tan
        4:  193:                if (func[0] == 't' && func[1] == 'a' && func[2] == 'n') {
        1:  194:                    item.type = 't';
        1:  195:                    item.value = 0;
        1:  196:                    push(&stack_o, item);
        1:  197:                }
        -:  198:                // log
        4:  199:                if (func[0] == 'l' && func[1] == 'o' && func[2] == 'g') {
    #####:  200:                    item.type = 'l';
    #####:  201:                    item.value = 0;
    #####:  202:                    push(&stack_o, item);
    #####:  203:                }
        4:  204:            }
        8:  205:            if (lenght == 2) {
        -:  206:                // ln
    #####:  207:                if (func[0] == 'l' && func[1] == 'n') {
    #####:  208:                    item.type = 'L';
    #####:  209:                    item.value = 0;
    #####:  210:                    push(&stack_o, item);
    #####:  211:                }
    #####:  212:            }
        8:  213:            if (lenght == 4) {
        -:  214:                // acos
        4:  215:                if (func[0] == 'a' && func[1] == 'c' && func[2] == 'o' && func[3] == 's') {
        1:  216:                    item.type = 'C';
        1:  217:                    item.value = 0;
        1:  218:                    push(&stack_o, item);
        1:  219:                }
        -:  220:                // asin
        4:  221:                if (func[0] == 'a' && func[1] == 's' && func[2] == 'i' && func[3] == 'n') {
        1:  222:                    item.type = 'S';
        1:  223:                    item.value = 0;
        1:  224:                    push(&stack_o, item);
        1:  225:                }
        -:  226:                // atan
        4:  227:                if (func[0] == 'a' && func[1] == 't' && func[2] == 'a' && func[3] == 'n') {
        1:  228:                    item.type = 'T';
        1:  229:                    item.value = 0;
        1:  230:                    push(&stack_o, item);
        1:  231:                }
        -:  232:                // sqrt
        4:  233:                if (func[0] == 's' && func[1] == 'q' && func[2] == 'r' && func[3] == 't') {
        1:  234:                    item.type = 'Q';
        1:  235:                    item.value = 0;
        1:  236:                    push(&stack_o, item);
        1:  237:                }
        4:  238:            }
        8:  239:        }
       40:  240:        if (searchString[i] == '+' || searchString[i] == '-' && flag == 0 || searchString[i] == '*' || searchString[i] == '/' || searchString[i] == '^' || searchString[i] == 'm') {
       12:  241:            if (sizeOfStack(&stack_o) == 0) {
        2:  242:                ch = searchString[i];
        2:  243:                item.type = ch;
        2:  244:                item.value = 0;
        2:  245:                push(&stack_o, item);
       12:  246:            } else if (sizeOfStack(&stack_o) != 0 && getPriority(searchString[i]) > getPriority(peek(&stack_o).type)) {
        3:  247:                ch = searchString[i];
        3:  248:                item.type = ch;
        3:  249:                item.value = 0;
        3:  250:                push(&stack_o, item);
        3:  251:            } else {
        7:  252:                mathStackElements(&stack_n,&stack_o,item,set);
        7:  253:                ch = searchString[i];
        7:  254:                item.type = ch;
        7:  255:                item.value = 0;
        7:  256:                push(&stack_o, item);
        -:  257:            }
       12:  258:            if (searchString[i] == 'm') {
    #####:  259:                i+=2;
    #####:  260:            }
       12:  261:        }
       40:  262:        if (searchString[i] == '(') {
        8:  263:            ch = searchString[i];
        8:  264:            item.type = ch;
        8:  265:            item.value = 0;
        8:  266:            push(&stack_o, item);
        8:  267:        }
       40:  268:        if (searchString[i] == ')') {
       13:  269:            while (peek(&stack_o).type != '(') {
        5:  270:                bool res = mathStackElements(&stack_n,&stack_o,item,set);
        5:  271:                if (res == true) {
    #####:  272:                    break;
        -:  273:                }
        -:  274:            }
        8:  275:            pop(&stack_o);
        8:  276:        }
       40:  277:        matchValue = 0;
       40:  278:    }
       13:  279:    while (sizeOfStack(&stack_o) != 0) {
        8:  280:        res =  mathStackElements(&stack_n,&stack_o,item,set);
        8:  281:        if (res == true) {
    #####:  282:            break;
        -:  283:        }
        -:  284:    }
        5:  285:    return  !res ? pop(&stack_n).value : 0.0;
        -:  286:}
        -:  287:
       20:  288:bool mathStackElements(Stack_t *stack_n, Stack_t *stack_o,value_type  item,charactersSet * set) {
        -:  289:    double value_a,value_b,value_res;
       20:  290:    bool error = false;
       20:  291:    value_a = peek(stack_n).value;
       20:  292:    pop(stack_n);
       20:  293:    switch (peek(stack_o).type) {
        -:  294:        case '+':
        2:  295:            if (sizeOfStack(stack_n) == 0) {
    #####:  296:                error = true;
    #####:  297:                set->errors = IS_ERROR_VALUE;
    #####:  298:                break;
        -:  299:            }
        2:  300:            value_b = peek(stack_n).value;
        2:  301:            value_res = value_b + value_a;
        2:  302:            item.type = '0';
        2:  303:            item.value = value_res;
        2:  304:            pop(stack_n);
        2:  305:            push(stack_n, item);
        2:  306:            pop(stack_o);
        2:  307:            break;
        -:  308:        case '-':
    #####:  309:            if (sizeOfStack(stack_n) == 0) {
    #####:  310:                error = true;
    #####:  311:                set->errors = IS_ERROR_VALUE;
    #####:  312:                break;
        -:  313:            }
    #####:  314:            value_b = peek(stack_n).value;
    #####:  315:            value_res = value_b - value_a;
    #####:  316:            item.type = '0';
    #####:  317:            item.value = value_res;
    #####:  318:            pop(stack_n);
    #####:  319:            push(stack_n, item);
    #####:  320:            pop(stack_o);
    #####:  321:            break;
        -:  322:        case '*':
        8:  323:            if (sizeOfStack(stack_n) == 0) {
    #####:  324:                error = true;
    #####:  325:                set->errors = IS_ERROR_VALUE;
    #####:  326:                break;
        -:  327:            }
        8:  328:            value_b = peek(stack_n).value;
        8:  329:            value_res = value_b * value_a;
        8:  330:            item.type = '0';
        8:  331:            item.value = value_res;
        8:  332:            pop(stack_n);
        8:  333:            push(stack_n, item);
        8:  334:            pop(stack_o);
        8:  335:            break;
        -:  336:        case '/':
        1:  337:            if (sizeOfStack(stack_n) == 0) {
    #####:  338:                error = true;
    #####:  339:                set->errors = IS_ERROR_VALUE;
    #####:  340:                break;
        -:  341:            }
        1:  342:            value_b = peek(stack_n).value;
        1:  343:            if (value_a != 0) {
        1:  344:                value_res = value_b / value_a;
        1:  345:                item.type = '0';
        1:  346:                item.value = value_res;
        1:  347:                pop(stack_n);
        1:  348:                push(stack_n, item);
        1:  349:                pop(stack_o);
        1:  350:            } else {
    #####:  351:                error = true;
    #####:  352:                set->errors = IS_ERROR_VALUE;
        -:  353:            }
        1:  354:            break;
        -:  355:        case 's':
        1:  356:            value_res = sinl(value_a);
        1:  357:            item.type = '0';
        1:  358:            item.value = value_res;
        1:  359:            push(stack_n, item);
        1:  360:            pop(stack_o);
        1:  361:            break;
        -:  362:        case 'c':
        2:  363:            value_res = cosl(value_a);
        2:  364:            item.type = '0';
        2:  365:            item.value = value_res;
        2:  366:            push(stack_n, item);
        2:  367:            pop(stack_o);
        2:  368:            break;
        -:  369:        case 't':
        1:  370:            if (Cos(value_a) == 0) {
    #####:  371:                error = true;
    #####:  372:                set->errors = IS_ERROR_VALUE;
    #####:  373:                break;
        -:  374:            }
        1:  375:            value_res = tanl(value_a);
        1:  376:            item.type = '0';
        1:  377:            item.value = value_res;
        1:  378:            push(stack_n, item);
        1:  379:            pop(stack_o);
        1:  380:            break;
        -:  381:        case 'l':
    #####:  382:            value_res = log10l(value_a);
    #####:  383:            item.type = '0';
    #####:  384:            item.value = value_res;
    #####:  385:            push(stack_n, item);
    #####:  386:            pop(stack_o);
    #####:  387:            break;
        -:  388:        case 'm':
    #####:  389:            if (sizeOfStack(stack_n) == 0) {
    #####:  390:                error = true;
    #####:  391:                set->errors = IS_ERROR_VALUE;
    #####:  392:                break;
        -:  393:            }
    #####:  394:            value_b = peek(stack_n).value;
    #####:  395:            value_res = fmodl(value_b,value_a);
    #####:  396:            item.type = '0';
    #####:  397:            item.value = value_res;
    #####:  398:            pop(stack_n);
    #####:  399:            push(stack_n, item);
    #####:  400:            pop(stack_o);
    #####:  401:            break;
        -:  402:        case 'L':
    #####:  403:            value_res = logl(value_a);
    #####:  404:            item.type = '0';
    #####:  405:            item.value = value_res;
    #####:  406:            push(stack_n, item);
    #####:  407:            pop(stack_o);
    #####:  408:            break;
        -:  409:        case 'C':
        1:  410:            if (value_a >= -1 && value_a <= 1) {
        1:  411:                value_res = acosl(value_a);
        1:  412:                item.type = '0';
        1:  413:                item.value = value_res;
        1:  414:                push(stack_n, item);
        1:  415:                pop(stack_o);
        1:  416:            } else {
    #####:  417:                error = true;
    #####:  418:                set->errors = IS_ERROR_VALUE;
        -:  419:            }
        1:  420:            break;
        -:  421:        case 'S':
        1:  422:            if (value_a >= -1 && value_a <= 1) {
        1:  423:                value_res = asinl(value_a);
        1:  424:                item.type = '0';
        1:  425:                item.value = value_res;
        1:  426:                push(stack_n, item);
        1:  427:                pop(stack_o);
        1:  428:            } else {
    #####:  429:                error = true;
    #####:  430:                set->errors = IS_ERROR_VALUE;
        -:  431:            }
        1:  432:            break;
        -:  433:        case 'T':
        1:  434:            value_res = atanl(value_a);
        1:  435:            item.type = '0';
        1:  436:            item.value = value_res;
        1:  437:            push(stack_n, item);
        1:  438:            pop(stack_o);
        -:  439:            
        1:  440:            break;
        -:  441:        case 'Q':
        1:  442:            value_res = sqrtl(value_a);
        1:  443:            item.type = '0';
        1:  444:            item.value = value_res;
        1:  445:            push(stack_n, item);
        1:  446:            pop(stack_o);
        1:  447:            break;
        -:  448:        case '^':
        1:  449:            if (sizeOfStack(stack_n) == 0) {
    #####:  450:                error = true;
    #####:  451:                set->errors = IS_ERROR_VALUE;
    #####:  452:                break;
        -:  453:            }
        1:  454:            value_b = peek(stack_n).value;
        1:  455:            if (value_a != 0) {
        1:  456:                value_res = pow(value_b,value_a);
        1:  457:                item.type = '0';
        1:  458:                item.value = value_res;
        1:  459:                pop(stack_n);
        1:  460:                push(stack_n, item);
        1:  461:                pop(stack_o);
        1:  462:            } else {
    #####:  463:                error = true;
    #####:  464:                set->errors = IS_ERROR_VALUE;
        -:  465:            }
        1:  466:            break;
        -:  467:        default:
    #####:  468:            break;
        -:  469:    }
       20:  470:    return error;
        -:  471:}
        -:  472:
       20:  473:int getPriority(char ch) {
       20:  474:    int priority = 0;
       20:  475:    if (ch == 'c' || ch == 's' || ch == 't' || ch == 'l' || ch == 'S' || ch == 'C' || ch == 'Q' || ch == 'T' || ch == 'L' || ch == 'm') {
        2:  476:        priority = 4;
        2:  477:    }
       20:  478:    if (ch == '+' || ch == '-') {
        3:  479:        priority = 1;
        3:  480:    }
       20:  481:    if (ch == '*' || ch == '/') {
       12:  482:        priority = 2;
       12:  483:    }
       20:  484:    if (ch == '^' ) {
        1:  485:        priority = 3;
        1:  486:    }
       20:  487:    return priority;
        -:  488:}
        -:  489:
       65:  490:void push(Stack_t *stack, value_type value) {
       65:  491:    if (stack->size >= STACK_MAX_SIZE) {
    #####:  492:        exit(STACK_OVERFLOW);
        -:  493:    }
       65:  494:    stack->data[stack->size] = value;
       65:  495:    stack->size++;
       65:  496:}
        -:  497:
       65:  498:value_type pop(Stack_t *stack) {
       65:  499:    if (stack->size == 0) {
    #####:  500:        exit(STACK_UNDERFLOW);
        -:  501:    }
       65:  502:    stack->size--;
       65:  503:    return stack->data[stack->size];
        -:  504:}
        -:  505:
       75:  506:value_type peek(const Stack_t *stack) {
       75:  507:    if (stack->size <= 0) {
    #####:  508:        exit(STACK_UNDERFLOW);
        -:  509:    }
       75:  510:    return stack->data[stack->size - 1];
        -:  511:}
    #####:  512:size_t stackIsEmpty(const Stack_t *stack) {
    #####:  513:    return stack->size == 0 ? 1 : 0;
        -:  514:}
        -:  515:
       47:  516:size_t sizeOfStack(const Stack_t * stack) {
       47:  517:    return stack->size;
        -:  518:}
        -:  519:
    #####:  520:double Sin(double x) {
    #####:  521:    return (round(sin(x) * 10000000) / 10000000);
        -:  522:}
        -:  523:
        1:  524:double Cos(double x) {
        1:  525:    return (round(cos(x) * 10000000) / 10000000);
        -:  526:}
